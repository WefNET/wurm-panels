<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wurm Trade Monitor</title>
    <style>
        body {
            font-family: Inter, Avenir, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: #111827;
            color: #f9fafb;
        }

        .titlebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(15, 23, 42, 0.95);
            padding: 6px 12px;
            font-size: 12px;
            letter-spacing: 0.04em;
            -webkit-app-region: drag;
        }

        .title-text {
            font-weight: 600;
        }

        .window-button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #f9fafb;
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            -webkit-app-region: no-drag;
        }

        .window-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .container {
            padding: 12px 16px 16px;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tab-button {
            flex: 1;
            background-color: #1f2937;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #e5e7eb;
            padding: 8px 0;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .tab-button:hover {
            background-color: #374151;
        }

        .tab-button.active {
            background-color: #2563eb;
            border-color: #3b82f6;
            color: white;
            font-weight: 600;
        }

        .tab-count {
            font-size: 11px;
            display: block;
            margin-top: 2px;
            opacity: 0.8;
        }

        .entries {
            background-color: #0f172a;
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .entry {
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            padding: 10px 0;
        }

        .entry:last-child {
            border-bottom: none;
        }

        .timestamp {
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 3px;
        }

        .message {
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .message-line {
            display: block;
            margin-bottom: 6px;
        }

        .message-line:last-child {
            margin-bottom: 0;
        }

        .message-text {
            display: inline;
            white-space: pre-wrap;
        }

        .item-card {
            display: inline-flex;
            flex-direction: column;
            gap: 4px;
            border-radius: 6px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(30, 41, 59, 0.7);
            padding: 6px 8px;
            margin: 2px 8px 2px 0;
            min-width: 140px;
        }

        .item-card.rarity-common {
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: inset 0 0 0 1px rgba(37, 99, 235, 0.25);
        }

        .item-card.rarity-rare {
            border-color: rgba(168, 85, 247, 0.55);
            box-shadow: inset 0 0 0 1px rgba(147, 51, 234, 0.35);
        }

        .item-card.rarity-supreme {
            border-color: rgba(250, 204, 21, 0.7);
            box-shadow: inset 0 0 0 1px rgba(234, 179, 8, 0.5);
        }

        .item-header {
            display: flex;
            align-items: baseline;
            gap: 6px;
        }

        .item-rarity-pill {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.88);
        }

        .item-name {
            font-size: 13px;
            font-weight: 600;
            color: #e5e7eb;
        }

        .item-material {
            font-size: 11px;
            text-transform: capitalize;
            color: #cbd5f5;
        }

        .item-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 11px;
            color: #e2e8f0;
        }

        .item-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .item-stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #94a3b8;
        }

        .item-casts,
        .item-runes {
            font-size: 11px;
            color: #fcd34d;
        }

        .item-runes {
            color: #f87171;
        }

        .empty-state {
            text-align: center;
            padding: 40px 12px;
            color: #9ca3af;
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="titlebar" data-tauri-drag-region>
        <span class="title-text">Wurm Trade Monitor</span>
        <button id="close-button" class="window-button" aria-label="Close trade window">Close</button>
    </div>
    <div class="container">
        <div class="tabs">
            <button class="tab-button active" data-category="WTS">WTS <span class="tab-count"
                    data-count="WTS">0</span></button>
            <button class="tab-button" data-category="WTB">WTB <span class="tab-count"
                    data-count="WTB">0</span></button>
            <button class="tab-button" data-category="PC">PC <span class="tab-count" data-count="PC">0</span></button>
            <button class="tab-button" data-category="PM">PM <span class="tab-count" data-count="PM">0</span></button>
        </div>
        <div class="entries" id="entries-container">
            <div class="empty-state">No trade messages yet. Keep an eye on the Trade channel!</div>
        </div>
    </div>

    <script>
        const closeButton = document.getElementById('close-button');
        const entriesContainer = document.getElementById('entries-container');
        const tabButtons = Array.from(document.querySelectorAll('.tab-button'));
        const tabCounts = Array.from(document.querySelectorAll('[data-count]'));

        const categories = ['WTS', 'WTB', 'PC', 'PM'];
        let activeCategory = 'WTS';
        let tradeEntries = [];

        const MAX_ITEMS_PER_LINE = 5;
        const RARITIES = new Set(['common', 'rare', 'supreme']);
        const MATERIAL_TOKENS = new Set([
            'iron',
            'steel',
            'silver',
            'gold',
            'copper',
            'bronze',
            'brass',
            'lead',
            'tin',
            'zinc',
            'electrum',
            'adamantine',
            'adamantium',
            'seryll',
            'glimmersteel',
            'glimmer',
            'marble',
            'slate',
            'granite',
            'sandstone',
            'obsidian',
            'stone',
            'leather',
            'cloth',
            'chain',
            'plate',
            'studded'
        ]);
        const CAST_DEFINITIONS = [
            // Recognized enchantments appear as "<label> <power>"
            { label: 'WoA', variants: ['woa', 'wind of ages'] },
            { label: 'CoC', variants: ['coc', 'circle of cunning'] },
            { label: 'BotD', variants: ['botd', 'blessing of the dark'] },
            { label: 'LT', variants: ['lt', 'life transfer'] },
            { label: 'MS', variants: ['ms', 'mind stealer'] },
            { label: 'Nim', variants: ['nim', 'nimbleness'] },
            { label: 'AoSP', variants: ['aosp', 'aura of shared pain'] },
            { label: 'FA', variants: ['fa', 'flaming aura'] },
            { label: 'FB', variants: ['fb', 'frostbrand'] },
            { label: 'Web', variants: ['web', 'web armour'] },
            { label: 'Venom', variants: ['venom'] },
            { label: 'BT', variants: ['bt', 'bloodthirst'] },
            { label: 'Courier', variants: ['courier'] },
            { label: 'Strongwall', variants: ['strongwall'] }
        ];

        if (closeButton) {
            closeButton.addEventListener('click', async () => {
                try {
                    const tauri = window.__TAURI__;
                    const tauriWindow = tauri?.window;
                    if (!tauriWindow?.getCurrent) {
                        await tauri?.core?.invoke?.('plugin:window|close', { label: 'trade' });
                        return;
                    }

                    const win = await tauriWindow.getCurrent();
                    if (win) {
                        await win.close();
                        return;
                    }

                    await tauri?.core?.invoke?.('plugin:window|close', { label: 'trade' });
                } catch (error) {
                    console.error('Failed to close trade window:', error);
                }
            });
        }

        function updateCounts() {
            const counts = new Map(categories.map((c) => [c, 0]));
            for (const entry of tradeEntries) {
                if (counts.has(entry.category)) {
                    counts.set(entry.category, counts.get(entry.category) + 1);
                }
            }

            for (const countEl of tabCounts) {
                const category = countEl.getAttribute('data-count');
                const value = counts.get(category) ?? 0;
                countEl.textContent = value.toString();
            }
        }

        function condenseWhitespace(text) {
            return text.replace(/\s+/g, ' ').trim();
        }

        function escapeRegex(value) {
            return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function isMaterialToken(token) {
            const lower = token.toLowerCase();
            if (MATERIAL_TOKENS.has(lower)) {
                return true;
            }
            if (
                lower.endsWith('wood') ||
                lower.endsWith('hide') ||
                lower.endsWith('fur') ||
                lower.endsWith('leather') ||
                lower.endsWith('cloth')
            ) {
                return true;
            }
            if (lower.endsWith('steel') && lower !== 'steel') {
                return true;
            }
            if (lower.endsWith('stone') && lower !== 'stone') {
                return true;
            }
            return false;
        }

        function toTitleCase(word) {
            if (!word) {
                return '';
            }
            if (word.length <= 2) {
                return word.toUpperCase();
            }
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }

        function formatNameToken(token) {
            return toTitleCase(token);
        }

        function formatRuneText(text) {
            const parts = text.split(/\s+/).filter(Boolean);
            return parts
                .map((part, index) => {
                    if (part.toLowerCase() === 'of' && index > 0) {
                        return 'of';
                    }
                    return toTitleCase(part);
                })
                .join(' ');
        }

        function buildCastPattern(definition) {
            const variantPattern = definition.variants
                .map((variant) => variant.split(/\s+/).map(escapeRegex).join('\\s+'))
                .join('|');
            return new RegExp(`\\b(?:${variantPattern})\\b\\s*:?\\s*(\\d+(?:\\.\\d+)?)?`, 'gi');
        }

        function parseItemContent(raw) {
            // Break down the bracketed item description into structured fields.
            const result = {
                raw,
                rarity: null,
                material: null,
                nameTokens: [],
                ql: null,
                dmg: null,
                wt: null,
                casts: [],
                runes: [],
                isStructured: false
            };

            if (typeof raw !== 'string') {
                return result;
            }

            let working = raw.replace(/[\u2022]/g, ' ');
            working = condenseWhitespace(working);

            function consumeStat(labels) {
                for (const label of labels) {
                    const regex = new RegExp(`\\b${label}\\s*:?\\s*(\\d+(?:\\.\\d+)?)`, 'i');
                    const match = regex.exec(working);
                    if (match) {
                        working = condenseWhitespace(working.replace(regex, ' '));
                        return match[1];
                    }
                }
                return null;
            }

            result.ql = consumeStat(['QL']);
            result.dmg = consumeStat(['DMG', 'Damage']);
            result.wt = consumeStat(['WT', 'Weight']);

            const runeRegex = /\b(?:rune(?:\s+of)?(?:\s+[A-Za-z][\w-]*){1,3})/gi;
            const runeMatches = working.match(runeRegex);

            if (runeMatches) {
                result.runes = runeMatches.map(formatRuneText);
                working = condenseWhitespace(working.replace(runeRegex, ' '));
            }

            const castMatches = [];

            for (const definition of CAST_DEFINITIONS) {
                const pattern = buildCastPattern(definition);
                const matches = Array.from(working.matchAll(pattern));
                if (matches.length) {
                    for (const match of matches) {
                        castMatches.push({
                            label: definition.label,
                            value: match[1] ? match[1].trim() : '',
                            index: match.index ?? 0
                        });
                    }
                    const cleanupPattern = buildCastPattern(definition);
                    working = condenseWhitespace(working.replace(cleanupPattern, ' '));
                }
            }

            castMatches.sort((a, b) => a.index - b.index);
            if (castMatches.length) {
                result.casts = castMatches.map(({ label, value }) => ({ label, value }));
            }

            working = condenseWhitespace(working);

            const tokens = working.split(/\s+/).filter(Boolean);
            if (tokens.length && RARITIES.has(tokens[0].toLowerCase())) {
                result.rarity = tokens.shift().toLowerCase();
            }

            const materialIndex = tokens.findIndex((token) => isMaterialToken(token));
            if (materialIndex !== -1) {
                result.material = tokens.splice(materialIndex, 1)[0];
            }

            result.nameTokens = tokens;
            result.isStructured = Boolean(
                result.rarity ||
                result.material ||
                result.ql ||
                result.dmg ||
                result.wt ||
                result.casts.length ||
                result.runes.length
            );

            return result;
        }

        function createItemElement(item) {
            const card = document.createElement('div');
            card.className = 'item-card';
            if (item.rarity) {
                card.classList.add(`rarity-${item.rarity}`);
            }

            const header = document.createElement('div');
            header.className = 'item-header';

            if (item.rarity) {
                const rarityPill = document.createElement('span');
                rarityPill.className = 'item-rarity-pill';
                rarityPill.textContent = toTitleCase(item.rarity);
                header.appendChild(rarityPill);
            }

            const displayTokens = item.nameTokens.length
                ? item.nameTokens
                : item.material
                    ? [item.material]
                    : [];

            let displayName = displayTokens.map(formatNameToken).join(' ');
            if (!displayName) {
                displayName = item.raw.trim();
            }

            const nameEl = document.createElement('span');
            nameEl.className = 'item-name';
            nameEl.textContent = displayName;
            header.appendChild(nameEl);

            card.appendChild(header);

            if (item.material && item.nameTokens.length) {
                const materialEl = document.createElement('div');
                materialEl.className = 'item-material';
                materialEl.textContent = `Material: ${formatNameToken(item.material)}`;
                card.appendChild(materialEl);
            }

            const stats = [];
            if (item.ql) {
                stats.push({ label: 'QL', value: item.ql });
            }
            if (item.dmg) {
                stats.push({ label: 'DMG', value: item.dmg });
            }
            if (item.wt) {
                stats.push({ label: 'WT', value: item.wt });
            }

            if (stats.length) {
                const statsEl = document.createElement('div');
                statsEl.className = 'item-stats';
                for (const stat of stats) {
                    const statEl = document.createElement('span');
                    statEl.className = 'item-stat';
                    const labelEl = document.createElement('span');
                    labelEl.className = 'item-stat-label';
                    labelEl.textContent = stat.label;
                    const valueEl = document.createElement('span');
                    valueEl.textContent = stat.value;
                    statEl.appendChild(labelEl);
                    statEl.appendChild(valueEl);
                    statsEl.appendChild(statEl);
                }
                card.appendChild(statsEl);
            }

            if (item.casts.length) {
                const castsEl = document.createElement('div');
                castsEl.className = 'item-casts';
                castsEl.textContent = item.casts
                    .map((cast) => (cast.value ? `${cast.label} ${cast.value}` : cast.label))
                    .join(' | ');
                card.appendChild(castsEl);
            }

            if (item.runes.length) {
                const runesEl = document.createElement('div');
                runesEl.className = 'item-runes';
                runesEl.textContent = item.runes.join(' | ');
                card.appendChild(runesEl);
            }

            return card;
        }

        function appendTextSegment(parent, text) {
            if (text === undefined || text === null || text === '') {
                return;
            }
            const span = document.createElement('span');
            span.className = 'message-text';
            span.textContent = text;
            parent.appendChild(span);
        }

        function renderMessageLine(line) {
            const lineWrapper = document.createElement('div');
            lineWrapper.className = 'message-line';

            if (line === '') {
                return lineWrapper;
            }

            const regex = /\[([^\]]+)\]/g;
            let lastIndex = 0;
            let match;
            let itemCount = 0;

            while ((match = regex.exec(line)) !== null) {
                const preceding = line.slice(lastIndex, match.index);
                appendTextSegment(lineWrapper, preceding);

                if (itemCount < MAX_ITEMS_PER_LINE) {
                    const parsed = parseItemContent(match[1]);
                    if (parsed.isStructured) {
                        lineWrapper.appendChild(createItemElement(parsed));
                    } else {
                        appendTextSegment(lineWrapper, match[0]);
                    }
                } else {
                    appendTextSegment(lineWrapper, match[0]);
                }

                itemCount += 1;
                lastIndex = regex.lastIndex;
            }

            const remaining = line.slice(lastIndex);
            appendTextSegment(lineWrapper, remaining);

            if (!lineWrapper.hasChildNodes()) {
                appendTextSegment(lineWrapper, line);
            }

            return lineWrapper;
        }

        function renderEntries() {
            const filtered = tradeEntries.filter((entry) => entry.category === activeCategory);

            if (filtered.length === 0) {
                entriesContainer.innerHTML = '<div class="empty-state">No messages captured for this tab yet.</div>';
                return;
            }

            entriesContainer.textContent = '';
            const fragment = document.createDocumentFragment();

            for (const entry of filtered) {
                const entryEl = document.createElement('div');
                entryEl.className = 'entry';

                const timestampEl = document.createElement('div');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = entry.timestamp || 'Unknown time';
                entryEl.appendChild(timestampEl);

                const messageEl = document.createElement('div');
                messageEl.className = 'message';

                if (typeof entry.message === 'string') {
                    const lines = entry.message.split(/\r?\n/);
                    for (const line of lines) {
                        messageEl.appendChild(renderMessageLine(line));
                    }
                }

                entryEl.appendChild(messageEl);
                fragment.appendChild(entryEl);
            }

            entriesContainer.appendChild(fragment);
        }

        function setActiveCategory(category) {
            if (!categories.includes(category)) {
                return;
            }

            activeCategory = category;
            for (const button of tabButtons) {
                const isActive = button.getAttribute('data-category') === category;
                button.classList.toggle('active', isActive);
            }
            renderEntries();
        }

        tabButtons.forEach((button) => {
            button.addEventListener('click', () => {
                const category = button.getAttribute('data-category');
                setActiveCategory(category);
            });
        });

        window.__TAURI__?.event?.listen('trade-entries', (evt) => {
            if (Array.isArray(evt.payload)) {
                tradeEntries = evt.payload;
                updateCounts();
                renderEntries();
            }
        });

        async function bootstrap() {
            try {
                const entries = await window.__TAURI__?.core?.invoke('get_trade_entries');
                if (Array.isArray(entries)) {
                    tradeEntries = entries;
                }
            } catch (error) {
                console.error('Failed to fetch initial trade entries:', error);
            } finally {
                updateCounts();
                renderEntries();
            }
        }

        void bootstrap();
    </script>
</body>

</html>